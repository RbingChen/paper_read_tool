<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>论文分析报告</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; }
        .original { background-color: #f0f0f0; border: 1px solid #ccc; padding: 15px; margin-bottom: 10px; }
        .translation { background-color: #e0f8e0; border: 1px solid #4CAF50; padding: 15px; margin-bottom: 20px; }
        .code-block { background-color: #ffffcc; padding: 15px; font-family: monospace; white-space: pre; overflow-x: auto; }
        .term { color: red; font-weight: bold; }
        h2 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; }
        section { margin-bottom: 30px; }
        .formula-container { text-align: center; margin: 20px 0; }
        .formula-number { display: block; font-style: italic; }
    </style>
</head>
<body>

<section id="understanding">
    <h2>内容理解</h2>
    <p>本文聚焦于<span class="term">基于人类反馈的强化学习（Reinforcement Learning from Human Feedback, RLHF）</span>中的关键挑战：奖励模型噪声问题。研究揭示了奖励模型评估中的不一致性——正确响应被赋予低奖励，而错误响应却获得高奖励。通过分析具体代码案例：</p>
    <ul>
        <li><strong>案例1</strong>：正确算法（分数转小数）因代码可读性问题（单行多操作）被低估</li>
        <li><strong>案例2</strong>：错误算法（括号位置错误）因格式问题被高估</li>
    </ul>
    <p>提出<span class="term">策略过滤（Policy Filtration）</span>作为解决方案，旨在提升奖励模型的评估鲁棒性。文中详细解析了分数转小数的算法实现，核心包括：符号处理、整数部分计算、余数循环检测机制（通过字典跟踪余数位置）和括号插入逻辑。</p>
</section>

<section id="translation">
    <h2>内容翻译</h2>
    
    <div class="original">
        Policy Filtration for RLHF to Mitigate Noise in Reward Models
        This is a correct response but assigned with a low reward. Compared with the previous response with high reward, this
        response mixes multiple operations in one line, making it harder to understand (e.g., Line 34).
    </div>
    <div class="translation">
        用于缓解奖励模型中噪声的RLHF策略过滤
        这是一个正确响应，但被分配了低奖励。与之前获得高奖励的响应相比，该响应将多个操作混合在一行中，导致更难理解（例如第34行）。
    </div>
    
    <div class="original">
        1To solve the problem of converting a fraction to its decimal representation, we can
        use the following approach:
        2
        31. Handle the sign of the result.
        42. Calculate the integral part of the result, which is the part before the decimal
        point.
        53. Handle the case where the fractional part is repeating.
        64. Calculate the fractional part and handle cycles.
    </div>
    <div class="translation">
        为解决将分数转换为其小数表示的问题，我们采用以下方法：
        <br>
        1. 处理结果的符号
        2. 计算结果的整数部分（小数点前的部分）
        3. 处理小数部分重复的情况
        4. 计算小数部分并处理循环
    </div>
    
    <div class="original">
        Here’s the completed Python code:
    </div>
    <div class="translation">
        完整Python代码如下：
    </div>
    
    <div class="code-block">
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        # Handle sign of result
        sign = '-' if numerator * denominator < 0 else ''
        numerator, denominator = abs(numerator), abs(denominator)

        # Calculate integral part
        integral_part = numerator // denominator

        # Calculate fractional part
        remainder = numerator % denominator
        if remainder == 0:
            return sign + str(integral_part)

        # Use a dictionary to track remainders and their positions
        # in the fractional part to detect cycles
        seen_remainders = {}
        result = []
        index = 0

        while remainder not in seen_remainders:
            seen_remainders[remainder] = index
            result.append(str(remainder * 10 // denominator))
            remainder = (remainder * 10) % denominator
            if remainder == 0:
                break
            index += 1

        # If there’s a cycle, insert the parentheses
        if remainder in seen_remainders:
            index = seen_remainders[remainder]
            result.insert(index, '(')
            result.append(')')

        return sign + str(integral_part) + '.' + ''.join(result)
    </div>
    <div class="translation">
        <div class="code-block">
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        # 处理结果符号
        sign = '-' if numerator * denominator < 0 else ''
        numerator, denominator = abs(numerator), abs(denominator)

        # 计算整数部分
        integral_part = numerator // denominator

        # 计算小数部分
        remainder = numerator % denominator
        if remainder == 0:
            return sign + str(integral_part)

        # 使用字典跟踪余数及其位置以检测循环
        seen_remainders = {}
        result = []
        index = 0

        while remainder not in seen_remainders:
            seen_remainders[remainder] = index
            result.append(str(remainder * 10 // denominator))
            remainder = (remainder * 10) % denominator
            if remainder == 0:
                break
            index += 1

        # 若存在循环，插入括号
        if remainder in seen_remainders:
            index = seen_remainders[remainder]
            result.insert(index, '(')
            result.append(')')

        return sign + str(integral_part) + '.' + ''.join(result)
        </div>
    </div>
    
    <div class="original">
        ### Explanation:
        - We first handle the signs of the numerator and denominator.
        - We then calculate the integral part of the result by integer division.
        - If the remainder is zero, the fraction is an integer and we return it as a string.
        - We use a dictionary ‘seen_remainders‘ to keep track of the positions where each remainder appears, allowing us to detect cycles.
        - If a cycle is detected, we insert parentheses at the start of the repeating part.
        - Finally, we assemble the result as a string and return it.
    </div>
    <div class="translation">
        ### 解释：
        - 首先处理分子和分母的符号
        - 通过整数除法计算结果的整数部分
        - 若余数为零，则分数为整数，直接返回字符串
        - 使用字典<span class="term">seen_remainders</span>跟踪余数出现位置以检测循环
        - 检测到循环时，在重复部分起始位置插入括号
        - 最终组装字符串结果并返回
    </div>
    
    <div class="original">
        This is an incorrect response but assigned with a high reward. In Line 32, the decimal point is added to the result list
        but is not later counted when getting wrapped by the parentheses, leading to the wrong format. This is a mixture of two
    </div>
    <div class="translation">
        这是一个错误响应，但被分配了高奖励。在第32行，小数点被添加到结果列表中，但在后续括号包裹时未被正确计数，导致格式错误。这是两种问题的混合。
    </div>
</section>

<section id="summary">
    <h2>摘要总结</h2>
    <p>本文提出<span class="term">策略过滤（Policy Filtration）</span>方法，用于解决<span class="term">基于人类反馈的强化学习（RLHF）</span>中奖励模型的噪声问题。核心发现包括：</p>
    <ul>
        <li>奖励模型存在评估偏差：<strong>正确算法</strong>因代码可读性问题（单行多操作）被低估，<strong>错误算法</strong>因格式错误（括号位置错误）被高估</li>
        <li>详细设计分数转小数算法，关键技术包括：符号处理、整数除法、余数循环检测（通过字典跟踪余数位置）和动态括号插入</li>
        <li>通过对比案例揭示奖励模型噪声对RLHF训练的影响机制</li>
    </ul>
    <p>研究强调需开发更鲁棒的奖励评估方法，确保算法正确性与代码质量得到准确评估。</p>
</section>

<section id="terms">
    <h2>术语识别</h2>
    <dl>
        <dt><span class="term">RLHF (Reinforcement Learning from Human Feedback)</span></dt>
        <dd>基于人类反馈的强化学习：通过人类偏好数据训练奖励模型，引导强化学习智能体优化的框架。核心挑战是奖励模型的噪声会扭曲学习过程。</dd>
        
        <dt><span class="term">Reward Model Noise (奖励模型噪声)</span></dt>
        <dd>奖励模型评估中的不一致性：表现为正确输出被分配低奖励值，错误输出被分配高奖励值。主要由标注偏差、模型欠拟合或过拟合引起。</dd>
        
        <dt><span class="term">Policy Filtration (策略过滤)</span></dt>
        <dd>本文提出的噪声缓解技术：通过算法筛选机制过滤掉奖励模型中的不可靠评估，确保只有高质量反馈用于策略更新。</dd>
        
        <dt><span class="term">Cycle Detection (循环检测)</span></dt>
        <dd>分数转小数的核心技术：通过字典记录余数出现位置（<code>seen_remainders</code>），当相同余数再次出现时判定为循环节，触发括号插入操作。</dd>
        
        <dt><span class="term">Remainder Tracking (余数跟踪)</span></dt>
        <dd>算法核心机制：在计算小数部分时，通过<code>remainder = (remainder * 10) % denominator</code>迭代更新余数，结合字典实现循环检测。</dd>
    </dl>
</section>

</body>
</html>